using System;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Generic;

namespace BuilderGenerator.Source
{
    [Generator]
    public class BuilderIncrementalGenerator : IIncrementalGenerator
    {
        private const string AttributeSource = @"
using System;
namespace BuilderGenerator.Runtime
{
    [AttributeUsage(AttributeTargets.Class, Inherited = false, AllowMultiple = false)]
    public sealed class GenerateBuilderAttribute : Attribute
    {
        public Type TargetType { get; set; }
    }
}
";

        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
#if DEBUG
            if (!System.Diagnostics.Debugger.IsAttached)
            {
                System.Diagnostics.Debugger.Launch();
            }
#endif
            // Добавляем атрибут через пост-инициализацию.
            context.RegisterPostInitializationOutput(ctx =>
            {
                ctx.AddSource("GenerateBuilderAttribute.g.cs", SourceText.From(AttributeSource, Encoding.UTF8));
            });

            var candidateClasses = context.SyntaxProvider
                .CreateSyntaxProvider(
                    predicate: static (node, ct) => IsCandidateClass(node),
                    transform: static (ctx, ct) => (ClassDeclarationSyntax)ctx.Node)
                .Where(static classDecl => classDecl is not null);

            IncrementalValueProvider<(Compilation, ImmutableArray<ClassDeclarationSyntax>)> compilationAndClasses =
                context.CompilationProvider.Combine(candidateClasses.Collect());

            context.RegisterSourceOutput(compilationAndClasses, (spc, source) =>
            {
                var (compilation, classes) = source;
                foreach (var classDecl in classes)
                {
                    var model = compilation.GetSemanticModel(classDecl.SyntaxTree);
                    if (model.GetDeclaredSymbol(classDecl) is not INamedTypeSymbol classSymbol)
                        continue;

                    var hasAttribute = classSymbol.GetAttributes().Any(ad =>
                        ad.AttributeClass?.ToDisplayString() == "BuilderGenerator.Runtime.GenerateBuilderAttribute" ||
                        ad.AttributeClass?.Name == "GenerateBuilderAttribute");

                    if (!hasAttribute)
                        continue;

                    // Определяем тип для генерации билдера.
                    ITypeSymbol targetType = classSymbol;
                    foreach (var attr in classSymbol.GetAttributes())
                    {
                        if (attr.AttributeClass?.ToDisplayString() == "BuilderGenerator.Runtime.GenerateBuilderAttribute" ||
                            attr.AttributeClass?.Name == "GenerateBuilderAttribute")
                        {
                            foreach (var namedArg in attr.NamedArguments)
                            {
                                if (namedArg.Key == "TargetType" && namedArg.Value.Value is INamedTypeSymbol ts)
                                    targetType = ts;
                            }
                        }
                    }

                    var builderSource = GenerateBuilderClass(compilation, targetType, classSymbol);
                    spc.AddSource($"{classSymbol.Name}Builder.g.cs", SourceText.From(builderSource, Encoding.UTF8));
                }
            });
        }

        private static bool IsCandidateClass(SyntaxNode node)
        {
            return node is ClassDeclarationSyntax cds && cds.AttributeLists.Count > 0;
        }

        private static string GenerateBuilderClass(
         Compilation compilation,
         ITypeSymbol targetType,
         INamedTypeSymbol classSymbol)
        {
            var namespaceName = classSymbol.ContainingNamespace.IsGlobalNamespace
                ? null
                : classSymbol.ContainingNamespace.ToDisplayString();

            var builderClassName = classSymbol.Name + "Builder";

            var sb = new StringBuilder();
            sb.AppendLine("// <auto-generated />");
            sb.AppendLine("using System;");
            sb.AppendLine();

            if (!string.IsNullOrEmpty(namespaceName))
            {
                sb.AppendLine($"namespace {namespaceName}");
                sb.AppendLine("{");
            }

            sb.AppendLine($"    public class {builderClassName}");
            sb.AppendLine("    {");
            sb.AppendLine($"        private readonly {targetType.ToDisplayString()} _instance = new {targetType.ToDisplayString()}();");
            sb.AppendLine();

            sb.AppendLine($"        public static {builderClassName} Create()");
            sb.AppendLine("        {");
            sb.AppendLine($"            return new {builderClassName}();");
            sb.AppendLine("        }");
            sb.AppendLine();

            var properties = targetType.GetMembers()
                .OfType<IPropertySymbol>()
                .Where(p => p.DeclaredAccessibility == Accessibility.Public && !p.IsStatic)
                .ToList();

            foreach (var prop in properties)
            {
                if (prop.Type.TypeKind == TypeKind.Class && prop.Type.SpecialType != SpecialType.System_String)
                {
                    var propBuilderClassName = prop.Type.Name + "Builder";
                    sb.AppendLine($"        public {builderClassName} {prop.Name}(Action<{propBuilderClassName}> buildAction)");
                    sb.AppendLine("        {");
                    sb.AppendLine($"            var builder = {propBuilderClassName}.Create();");
                    sb.AppendLine("            buildAction(builder);");
                    sb.AppendLine($"            _instance.{prop.Name} = builder.Build();");
                    sb.AppendLine("            return this;");
                    sb.AppendLine("        }");
                    sb.AppendLine();
                }
                else
                {
                    sb.AppendLine($"        public {builderClassName} {prop.Name}({prop.Type.ToDisplayString()} value)");
                    sb.AppendLine("        {");
                    sb.AppendLine($"            _instance.{prop.Name} = value;");
                    sb.AppendLine("            return this;");
                    sb.AppendLine("        }");
                    sb.AppendLine();
                }
            }

            sb.AppendLine($"        public {targetType.ToDisplayString()} Build()");
            sb.AppendLine("        {");
            sb.AppendLine("            return _instance;");
            sb.AppendLine("        }");
            sb.AppendLine();

            sb.AppendLine($"        public static implicit operator {targetType.ToDisplayString()}({builderClassName} builder)");
            sb.AppendLine("        {");
            sb.AppendLine("            return builder.Build();");
            sb.AppendLine("        }");

            sb.AppendLine("    }");

            if (!string.IsNullOrEmpty(namespaceName))
            {
                sb.AppendLine("}");
            }

            return sb.ToString();
        }



        /// <summary>
        /// Returns true if the property type is a class (excluding string),
        /// which indicates that we might want to handle it with a builder.
        /// </summary>
        private static bool IsReferenceCandidate(IPropertySymbol prop)
        {
            return prop.Type.TypeKind == TypeKind.Class
                   && prop.Type.SpecialType != SpecialType.System_String;
        }





       



       
    }
}
